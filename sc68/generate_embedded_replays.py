#!/usr/bin/env python3
"""
Generate embedded_replays.h from binary replay files.

Converts all .bin files in file68/data68/Replay/ to C arrays that can be
compiled directly into the SC68 plugin, eliminating external file dependencies.
"""

import os
import sys
from pathlib import Path

def sanitize_name(filename: str) -> str:
    """Convert filename to valid C identifier."""
    name = Path(filename).stem
    # Replace non-alphanumeric chars with underscore
    result = ""
    for c in name:
        if c.isalnum():
            result += c.lower()
        else:
            result += "_"
    return result

def generate_header(replay_dir: Path, output_file: Path) -> None:
    """Generate C header with embedded replay data."""

    # Find all binary files
    files = sorted(replay_dir.glob("*.bin"))
    if not files:
        print(f"No .bin files found in {replay_dir}", file=sys.stderr)
        sys.exit(1)

    print(f"Found {len(files)} replay files")

    with open(output_file, "w") as f:
        f.write("""// Auto-generated file - do not edit manually
// Generated by generate_embedded_replays.py
//
// Contains embedded SC68 replay routines compiled directly into the plugin.
// Total files: {count}

#ifndef SC68_EMBEDDED_REPLAYS_H
#define SC68_EMBEDDED_REPLAYS_H

#include <stddef.h>
#include <stdint.h>

""".format(count=len(files)))

        # Generate array for each file
        total_size = 0
        replay_info = []

        for bin_file in files:
            data = bin_file.read_bytes()
            size = len(data)
            total_size += size
            name = sanitize_name(bin_file.name)
            original_name = bin_file.stem  # Name without .bin extension

            replay_info.append((name, original_name, size))

            f.write(f"// {bin_file.name} ({size} bytes)\n")
            f.write(f"static const uint8_t s_replay_{name}[] = {{\n")

            # Write data in rows of 16 bytes
            for i in range(0, size, 16):
                chunk = data[i:i+16]
                hex_str = ", ".join(f"0x{b:02x}" for b in chunk)
                f.write(f"    {hex_str},\n")

            f.write("};\n\n")

        # Generate lookup table
        f.write("""
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Replay lookup table

typedef struct {
    const char* name;           // Replay name (matches SC68 replay requests)
    const uint8_t* data;        // Pointer to embedded data
    size_t size;                // Size in bytes
} Sc68EmbeddedReplay;

static const Sc68EmbeddedReplay s_embedded_replays[] = {
""")

        for name, original_name, size in replay_info:
            f.write(f'    {{ "{original_name}", s_replay_{name}, {size} }},\n')

        f.write("""    { NULL, NULL, 0 }  // Sentinel
};

#define SC68_EMBEDDED_REPLAY_COUNT """ + str(len(files)) + """

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Lookup function

static inline const Sc68EmbeddedReplay* sc68_find_embedded_replay(const char* name) {
    for (int i = 0; s_embedded_replays[i].name != NULL; i++) {
        // Case-insensitive comparison
        const char* a = name;
        const char* b = s_embedded_replays[i].name;
        int match = 1;
        while (*a && *b) {
            char ca = *a >= 'A' && *a <= 'Z' ? *a + 32 : *a;
            char cb = *b >= 'A' && *b <= 'Z' ? *b + 32 : *b;
            if (ca != cb) {
                match = 0;
                break;
            }
            a++;
            b++;
        }
        if (match && *a == '\\0' && *b == '\\0') {
            return &s_embedded_replays[i];
        }
    }
    return NULL;
}

#endif // SC68_EMBEDDED_REPLAYS_H
""")

        print(f"Generated {output_file}")
        print(f"Total embedded data: {total_size:,} bytes ({total_size/1024:.1f} KB)")

def main():
    script_dir = Path(__file__).parent
    replay_dir = script_dir / "file68" / "data68" / "Replay"
    output_file = script_dir / "embedded_replays.h"

    if not replay_dir.exists():
        print(f"Replay directory not found: {replay_dir}", file=sys.stderr)
        sys.exit(1)

    generate_header(replay_dir, output_file)

if __name__ == "__main__":
    main()
