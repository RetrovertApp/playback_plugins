--- a/src/pxtnService.h
+++ b/src/pxtnService.h
@@ -16,6 +16,11 @@
 
 #define PXTONEERRORSIZE 64
 
+/* Scope capture ring buffer constants */
+#define PXTONE_SCOPE_BUFFER_SIZE      1024
+#define PXTONE_SCOPE_BUFFER_MASK      (PXTONE_SCOPE_BUFFER_SIZE - 1)
+#define PXTONE_SCOPE_MAX_CHANNELS     32
+
 #define pxtnVOMITPREPFLAG_loop      0x01
 #define pxtnVOMITPREPFLAG_unit_mute 0x02
 
@@ -132,6 +137,11 @@ private:
 
 	pxtnPulse_Frequency* _moo_freq ;
 
+	/* Scope capture ring buffers for per-unit audio visualization */
+	float    _moo_scope_buffer[PXTONE_SCOPE_MAX_CHANNELS][PXTONE_SCOPE_BUFFER_SIZE];
+	uint32_t _moo_scope_write_pos[PXTONE_SCOPE_MAX_CHANNELS];
+	int      _moo_scope_enabled;
+
 	pxtnERR _init           ( int32_t fix_evels_num, bool b_edit );
 	bool    _release        ();
 	pxtnERR _pre_count_event( void* desc, int32_t* p_count );
@@ -245,6 +255,10 @@ public :
 	bool    moo_set_tempo_mod( float tempo_mod );
 
 	bool    Moo( void* p_buf, int32_t size );
+
+	/* Scope capture API */
+	void     moo_enable_scope_capture( int enable );
+	uint32_t moo_get_scope_data( int channel, float *buffer, uint32_t num_samples ) const;
 };
 
 int32_t pxtnService_moo_CalcSampleNum( int32_t meas_num, int32_t beat_num, int32_t sps, float beat_tempo );
--- a/src/pxtnService_moo.cpp
+++ b/src/pxtnService_moo.cpp
@@ -25,6 +25,8 @@ void pxtnService::_moo_constructor()
 
 	_moo_smp_count      =     0;
 	_moo_smp_end        =     0;
+
+	_moo_scope_enabled  =     0;
 }
 
 bool pxtnService::_moo_release()
@@ -198,10 +200,34 @@ bool pxtnService::_moo_PXTONE_SAMPLE( void *p_data )
 		_units[ u ]->Tone_Sample( _moo_b_mute_by_unit, _dst_ch_num, _moo_time_pan_index, _moo_smp_smooth );
 	}
 
+	/* Per-unit scope contribution accumulators (sum across stereo channels) */
+	int32_t scope_unit_sums[ PXTONE_SCOPE_MAX_CHANNELS ];
+	int32_t scope_capture_count = 0;
+	if( _moo_scope_enabled )
+	{
+		scope_capture_count = _unit_num < PXTONE_SCOPE_MAX_CHANNELS ? _unit_num : PXTONE_SCOPE_MAX_CHANNELS;
+		for( int32_t u = 0; u < scope_capture_count; u++ ) scope_unit_sums[ u ] = 0;
+	}
+
 	for( int32_t ch = 0; ch < _dst_ch_num; ch++ )
 	{
 		for( int32_t g = 0; g < _group_num; g++ ) _moo_group_smps[ g ] = 0;
-		for( int32_t u = 0; u < _unit_num ; u++ ) _units [ u ]->Tone_Supple(     _moo_group_smps, ch, _moo_time_pan_index );
+		for( int32_t u = 0; u < _unit_num ; u++ )
+		{
+			if( _moo_scope_enabled && u < PXTONE_SCOPE_MAX_CHANNELS )
+			{
+				int32_t total_before = 0;
+				for( int32_t g = 0; g < _group_num; g++ ) total_before += _moo_group_smps[ g ];
+				_units[ u ]->Tone_Supple( _moo_group_smps, ch, _moo_time_pan_index );
+				int32_t total_after = 0;
+				for( int32_t g = 0; g < _group_num; g++ ) total_after += _moo_group_smps[ g ];
+				scope_unit_sums[ u ] += ( total_after - total_before );
+			}
+			else
+			{
+				_units[ u ]->Tone_Supple( _moo_group_smps, ch, _moo_time_pan_index );
+			}
+		}
 		for( int32_t o = 0; o < _ovdrv_num; o++ ) _ovdrvs[ o ]->Tone_Supple(     _moo_group_smps );
 		for( int32_t d = 0; d < _delay_num; d++ ) _delays[ d ]->Tone_Supple( ch, _moo_group_smps );
 
@@ -221,6 +247,17 @@ bool pxtnService::_moo_PXTONE_SAMPLE( void *p_data )
 		*( (int16_t*)p_data + ch ) = (int16_t)( work );
 	}
 
+	/* Write per-unit mono scope samples from accumulated channel contributions */
+	if( _moo_scope_enabled )
+	{
+		for( int32_t u = 0; u < scope_capture_count; u++ )
+		{
+			float mono = (float)scope_unit_sums[ u ] / ( 32768.0f * (float)_dst_ch_num );
+			_moo_scope_buffer[ u ][ _moo_scope_write_pos[ u ] & PXTONE_SCOPE_BUFFER_MASK ] = mono;
+			_moo_scope_write_pos[ u ]++;
+		}
+	}
+
 	// --------------
 	// increments..
 
@@ -514,3 +551,40 @@ int32_t pxtnService_moo_CalcSampleNum( int32_t meas_num, int32_t beat_num, int32
 	sample_num     = (uint32_t )( (double)sps * 60 * (double)total_beat_num / (double)beat_tempo );
 	return sample_num;
 }
+
+void pxtnService::moo_enable_scope_capture( int enable )
+{
+	_moo_scope_enabled = enable;
+
+	if( enable )
+	{
+		memset( _moo_scope_buffer, 0, sizeof( _moo_scope_buffer ) );
+		memset( _moo_scope_write_pos, 0, sizeof( _moo_scope_write_pos ) );
+	}
+}
+
+uint32_t pxtnService::moo_get_scope_data( int channel, float *buffer, uint32_t num_samples ) const
+{
+	uint32_t read_pos;
+	uint32_t i;
+
+	if( !buffer || !_moo_scope_enabled )
+		return 0;
+
+	if( channel < 0 || channel >= PXTONE_SCOPE_MAX_CHANNELS || channel >= _unit_num )
+		return 0;
+
+	if( num_samples > PXTONE_SCOPE_BUFFER_SIZE )
+		num_samples = PXTONE_SCOPE_BUFFER_SIZE;
+
+	read_pos = ( _moo_scope_write_pos[ channel ] - num_samples + PXTONE_SCOPE_BUFFER_SIZE )
+		& PXTONE_SCOPE_BUFFER_MASK;
+
+	for( i = 0; i < num_samples; i++ )
+	{
+		buffer[ i ] = _moo_scope_buffer[ channel ][ read_pos ];
+		read_pos = ( read_pos + 1 ) & PXTONE_SCOPE_BUFFER_MASK;
+	}
+
+	return num_samples;
+}
